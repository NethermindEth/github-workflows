# This workflow is used to build and push Docker images to JFrog Artifactory.
# Structure of the workflow:
# - It is triggered by a workflow call.
# - It checks out the code from the repository.
# - It runs pre-commit hooks to ensure code quality.
# - If workflow triggered by a push to main, it creates a changelog and version bump using commitizen.
# - It defines the image tag.
# - It installs JFrog CLI and logs in to Artifactory using the OIDC token.
# - It sets up QEMU and Docker Buildx for multi-platform builds.
# - It builds and pushes the Docker image to Artifactory.
# - It collects environment variables and Git information for the build.
# - It adds the built images to the JFrog build context.
# - It publishes the build information to JFrog Artifactory.

name: CI pull request

on:
  workflow_call:
    inputs:
      is_pull_request:
        description: 'Is this a pull request?'
        type: boolean
        default: false
      artifactory_project:
        description: 'Key of the Artifactory project'
        type: string
        required: true
      image_reportory:
        description: 'Repository name'
        type: string
        required: true
      image_name:
        description: 'Name of the image to publish. Defaults to the repository name.'
        type: string
        required: false
        default: "${{ github.event.repository.name }}"
      platforms:
        description: 'Comma-separated list of platforms (e.g., linux/amd64,linux/arm64)'
        type: string
        required: true

permissions:
  id-token: write
  contents: write
  attestations: write

jobs:
  pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}

      - name: Run pre-commit
        uses: pre-commit/action@v3.0.1

      - id: cz
        if: inputs.is_pull_request == false
        name: Create bump and changelog
        uses: commitizen-tools/commitizen-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Define image tag
        id: set_tag
        run: |
          HEAD_REF=${{ github.head_ref }}
          HEAD_SLUG=${HEAD_REF//\//-}
          if [[ "${{ steps.cz.conclusion }}" == "success" ]]; then
            IMAGE_TAG=${{ steps.cz.outputs.version }}
          else
            IMAGE_TAG=${HEAD_SLUG}-${{ github.sha }}
          fi
          echo "HEAD_SLUG=${HEAD_SLUG}" >> $GITHUB_ENV
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

      - name: Install JFrog CLI
        id: jfrog
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ inputs.artifactory_project }}
        with:
          oidc-provider-name: github-nethermindeth

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}
          username: ${{ steps.jfrog.outputs.oidc-user }}
          password: ${{ steps.jfrog.outputs.oidc-token }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          push: true
          platforms: ${{ inputs.platforms }}
          tags: |
            ${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}/${{ inputs.image_name }}:latest
            ${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}/${{ inputs.image_name }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Attest
        uses: actions/attest-build-provenance@c074443f1aee8d4aeeae555aebba3282517141b2 # v2.2.3
        id: attest
        with:
          subject-name: ${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}/${{ inputs.image_name }}
          subject-digest: ${{ steps.build.outputs.digest }}
          push-to-registry: true

      - name: JFrog build add context
        env:
          JFROG_CLI_BUILD_NAME: ${{ inputs.image_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.HEAD_SLUG }}-${{ github.run_number }}
        run: |
          jf rt build-collect-env
          jf rt build-add-git

      - name: JFrog build add images
        env:
          JFROG_CLI_BUILD_NAME: ${{ inputs.image_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.HEAD_SLUG }}-${{ github.run_number }}
        run: |
          # Pull image manifest
          docker manifest inspect ${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}/${{ inputs.image_name }}:${{ env.IMAGE_TAG }} > manifest.json

          # Iterate over platforms
          platforms=$(echo ${{ inputs.platforms }} | tr ',' ' ')
          for platform in $platforms; do
            os=$(echo $platform | cut -d'/' -f1)
            arch=$(echo $platform | cut -d'/' -f2)
            digest=$(jq -r \
              --arg os "${os}" \
              --arg arch "${arch}" \
              '.manifests[] | select(.platform.os==$os and .platform.architecture==$arch) | .digest' manifest.json)
            echo "${{ vars.JFROG_HOST }}/${{ inputs.image_reportory }}/${{ inputs.image_name }}:${{ env.IMAGE_TAG }}@${digest}" > image-file
            jf rt build-docker-create --image-file=image-file ${{ inputs.image_reportory }}
          done

      - name: JFrog build publish
        env:
          JFROG_CLI_BUILD_NAME: ${{ inputs.image_name }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.HEAD_SLUG }}-${{ github.run_number }}
        run: |
          jf rt build-publish
